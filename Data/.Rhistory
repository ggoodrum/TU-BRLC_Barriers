'Fielding_40',
'Fielding_70',
'WV_400',
'WV_333',
'WV_330',
'WV_319',
'WV_309',
'WV_170'),
Storage = c(27000,
51000,
41000,
40000,
70000,
400000,
333000,
330000,
319000,
309000,
170000))
data.frame(Reservoir = c('Cub River',
'Above Cutler',
'Temple Fork',
'Fielding_40',
'Fielding_70',
'WV_400',
'WV_333',
'WV_330',
'WV_319',
'WV_309',
'WV_170'),
stor_acft = c(27000,
51000,
41000,
40000,
70000,
400000,
333000,
330000,
319000,
309000,
170000)) %>%
dplyr::mutate(stor_m3 = stor_acft * acft_to_m3) %>%
dplyr::mutate(stor_Mm3 = stor_m3 / 1e6) %>%
as.data.frame
library(dplyr)
data.storage <- data.frame(Reservoir = c('Cub River',
'Above Cutler',
'Temple Fork',
'Fielding_40',
'Fielding_70',
'WV_400',
'WV_333',
'WV_330',
'WV_319',
'WV_309',
'WV_170'),
stor_acft = c(27000,
51000,
41000,
40000,
70000,
400000,
333000,
330000,
319000,
309000,
170000)) %>%
dplyr::mutate(stor_m3 = stor_acft * acft_to_m3) %>%
dplyr::mutate(stor_Mm3 = stor_m3 / 1e6) %>%
as.data.frame
data.storage
View(data.storage)
406.9 + 86.3
381 + 49.3 + 62.8
410.6 + 49.3 + 33.3
393.3 + 49.3 + 50.6
209.6 + 86.3 + 62.8 + 33.3 + 50.6
209.6 + 86.3 + 62.8 + 33.3 + 50.6
(0.364 + 0.636)
(0.364 * 0.636)
(0.364 * 0.328)
(0.636 * 0.)
(0.636 * 0.223)
11.9+14.2
acft_to_m3 <- 1.233e3
(220000 * acft_to_m3) / 1e6
acft_to_m3 <- 1.233e3
((402 * 1000) * acft_to_m3) / 1e6
data <- c(rep(400000, 4))
data <- c(rep(400000, 7))
mean(data)
data <- c(rep(400000, 7), 414000, 244000, 610000, 610000, 608000, 622000)
mean(data)
min(data)
max(data)
acft_to_m3 <- 1.233e3
(454464.5 * acft_to_m3) / 1e6
(244000 * acft_to_m3) / 1e6
(622000 * acft_to_m3) / 1e6
acft_to_m3 <- 1.233e3
1 / (1 * acft_to_m3)
0.00001*10000
0.00001*1000
acft_to_m3 <- 1.233e3
0.01 / (acft_to_m3)
0.01 * (acft_to_m3)
1/(acft_to_m3)
1280.8 - 1278.1
12/140
boa <- 2203 - 300
boa
boa + 680 + 80 + 100
boa + 680 + 80 + 100 + (6 * 25)
boa <- 1888.42
fid <- 435.88 - 300
fid
2692 - (278.47 + 166.91 + 39.04)
2692 - (278.47 + 166.91 + 39.04 + 115)
yc <- 2092
boa - fid + yc
boa - fid + yc - 1200
boa - fid + yc - 1800
boa <- 2784.42
fid <- (294.14 + 23.04 + 38.5 + 84 + 77.29 - 29.73)
fid
fid <- (294.14 + 23.04 + 38.5 + 84 + 77.29 - 29.73) - 300
fid
yc <- 2000
opal <- 18 * 30
opal
boa + (200 - fid) + opal
boa + (200 - fid) + opal + yc
5337 - 1800
boa <- 2758.42
fid <- 409.93 - 200
fid
100 - (16 * 2)
jacket <- 215 + (14*2)
jacket
hoodie < 109
hoodie <- 109
109 + 135
109*2
boa <- 1031.51
fid <- 57.73 + 103.64
fid
cash <- 100
cash <- 120
rent.08_09 <- 1200
util <- 105 *4
util
util <- 105 *6
util
yell <- 2000
karin <- 30 * 19
karin
peter <- 30 * 9
peter
peter + karin
(boa + karin + yell + peter)
(boa + karin + yell + peter) - (rent.08_09 + utils + fid)
(boa + karin + yell + peter) - (rent.08_09 + util + fid)
parallel::detectCores()
boa <- 1931.51
fid <- 455.58 + 136.16
fid
jim_lori <- 200
cash <- 400
balance <- boa + cash - fid
balance
cash <- 300
balance
balance <- boa + cash - fid
balance
balance.wYC <- balance + 2092
balance.wYC
balance.wYC - 1200.
yoshi <- 9 * 25
yoshi
balance.wYC + yoshin
balance.wYC + yoshi
balance.wYC + yoshi - 1200
boa - 550
fid
boa - 450
fid - 450
boa <- 1881.51
fid.pay <- 450
fid <- 559.64 + 91.87
fid
fid.bal <- fid - fid.pay
fid.bal
yoshi <- 9 * 25
yoshi
yoshi <- 9 * 30
yoshi
yoshi <- 9 * 25
boa + yoshi - 600 -  fid.bal
1346 + 298 + 856 + 17610 + 79 + 57
85000  / 12
06 / 60
10/3600
((60 * 8) + 27) / ((60 * 13) + 7)
118 + 21
((60 * 7) + 47) / ((60 * 13) + 7)
((60 * 8) + 33) / ((60 * 13) + 7)
# --------------------------------------------------------------------- #
# 00. Set up workspace
# ---------------------------------------------------------------------
# Summary: Set up workspace, load data, and load relevant packages.
# Clean workspace
rm(list = ls())
# Load Packages
# Data/stats
if(!require("rstudioapi")){
install.packages("rstudioapi", dependencies = TRUE); library(rstudioapi)}
if(!require("tidyverse")){
install.packages("tidyverse", dependencies = TRUE); library(tidyverse)}
if(!require("rio")){
install.packages("rio", dependencies = TRUE); library(rio)}
if(!require("lubridate")){
install.packages("lubridate", dependencies = TRUE); library(lubridate)}
# Connectivity
if(!require("igraph")){
install.packages("igraph", dependencies = TRUE); library(igraph)}
if(!require("riverconn")){
install.packages("riverconn", dependencies = TRUE); library(riverconn)}
if(!require("ggnetwork")){
install.packages("ggnetwork", dependencies = TRUE); library(ggnetwork)}
# Plotting
if(!require("viridis")){
install.packages("viridis", dependencies = TRUE); library(viridis)}
# Declare working directory
pwd <- dirname(rstudioapi::getSourceEditorContext()$path)
setwd(pwd)
# ---------------------------------------------------------------------
# --------------------------------------------------------------------- #
# 00. Initialize functions
# ---------------------------------------------------------------------
# FUNCTION: network_check() - Verify network structure such at all vertices are unique
#                             and all confluences are binary.
network_check <- function(inData, From_field, To_field){
# Check that From_Nodes are all unique
check.reaches    <- as.data.frame(inData %>% group_by({{From_field}}) %>% filter(n() > 1))
# Check that nodes occur no more than twice in To_Node (binary junctions)
check.confluences <- as.data.frame(inData %>% group_by({{To_field}}) %>% filter(n() > 2))
# Check that To_Nodes all come from From_Nodes
# NOTE: For network generation that produces a non-existent terminal node, there
#       should be one row in data.outlet. For a network without a non-existent
#       terminal node, data.outlet should be blank.
check.outlet <- inData %>% filter(!{{To_field}} %in% {{From_field}})
# Print error outputs
# ifelse(nrow(check.reaches)     > 0, print('NETWORK CHECK: Duplicate vertices (From nodes)'),
# ifelse(nrow(check.confluences) > 0, print('NETWORK CHECK: Nonbinary confluences'),
# ifelse(nrow(check.outlet)      > 1, print('NETWORK CHECK: Nonbinary terminal reaches'),
# ifelse(nrow(check.outlet)     == 1, print('NETWORK CHECK: To_node not present in From_node'),
#                                     print('Network check complete')))))
if(nrow(check.reaches)     > 0) {print('NETWORK CHECK: Duplicate vertices (From nodes) detected')}
if(nrow(check.confluences) > 0) {print('NETWORK CHECK: Nonbinary confluences detected')}
if(nrow(check.outlet)      > 1) {print('NETWORK CHECK: Nonbinary terminal reaches detected')}
if(nrow(check.outlet)     == 1) {print('NETWORK CHECK: To_node not present in From_node detected')}
print('Network check complete')
return(list(Duplicate_Reaches     = check.reaches,
Nonbinary_Confluences = check.confluences,
Terminal_Reaches      = check.outlet))
}
# ---------------------------------------------------------------------------- #
# FUNCTION: generate_attributed_igraph() - Generate an igraph object with edge and vertex attributes,
#                                         add passability fields, and set graph directionality.
generate_attributed_igraph <- function(inData,
From_field,
To_field,
EdgeType_field,
Edge_attributes,
Node_attributes,
Outlet_node,
graphFile){
# Select edge data and remove nodes not associated with a reach
data.edges <- inData %>% select({{From_field}},
{{To_field}},
{{Edge_attributes}}) %>%
filter({{To_field}} %in% {{From_field}})
# Set edge type field
data.edges <- data.edges %>% mutate(type = ifelse(get({{EdgeType_field}}) == "",
'Confluence',
get({{EdgeType_field}})))
# Generate igraph object with edge attributes
data.graph <- graph_from_data_frame(data.edges)
# Select node data
data.nodes <- inData %>% select({{From_field}},
{{Node_attributes}})
# Attribute nodes
for(col in colnames(data.nodes)){
data.graph <- set_vertex_attr(data.graph,
name = col,
index = V(data.graph),
value = sapply(V(data.graph)$name, function(x){
unlist(data.nodes %>%
filter(From_Node == x) %>%
.[col])
}))
}
# Assign network directionality based on outlet reach
data.graph <- set_graph_directionality(data.graph,
field_name = 'name',
outlet_name = as.character(Outlet_node))
# Initialize passability fields
field.pass <- c('pass_u', 'pass_d')
for(i in 1:length(field.pass)){
data.graph <- set_edge_attr(data.graph,
field.pass[i],
value = 1.0)
}
# Identify outlet edge for plotting
index.outlet <- which(V(data.graph)$name == Outlet_node)
# Set plotting dimensions
size.plot <- data.frame(node  = NA,
edge  = NA,
arrow = NA,
text  = NA)
ifelse(length(V(data.graph)) <= 100,  size.plot[1,] <- c(0.1, 1, 10, 5),
ifelse(length(V(data.graph)) <= 1000, size.plot[1,] <- c(0.05, 0.5, 5, 2.5),
size.plot[1,] <- c(0.01, 0.1, 1, 0.5)))
# Plot to confirm
gg0 <- ggnetwork(data.graph,
layout =  layout_as_tree(data.graph %>% as.undirected, root = index.outlet),
scale = FALSE)
plot <-
ggplot(gg0, aes(x = x, y = y, xend = xend, yend = yend)) +
geom_nodes(alpha = 0.3,
size = size.plot$node) +
geom_edges(alpha = 0.5,
arrow = arrow(length = unit(size.plot$arrow, "pt"), type = "closed"),
linewidth = size.plot$edge,
aes(color = type)) +
scale_color_viridis(discrete = TRUE)+
geom_nodetext(aes(label = name), fontface = "bold",
size = size.plot$text) +
theme_blank()
ggsave(graphFile, plot = plot,
width = 40, height = 40, units = 'cm',
dpi = 600)
return(data.graph)
}
# ---------------------------------------------------------------------------- #
# FUNCTION: join_edge_attributes() - Function that joins edge attributes based on a common identifier field.
#                                    Function currently hard-coded for 'UID', 'Type_R', and 'Pass_R' fields.
join_edge_attributes <- function(inGraph, inData, field.pass){
# Initialize output
outGraph <- inGraph
# Join pass field
outGraph <- set_edge_attr(outGraph,
name = as.name(field.pass),
index = E(outGraph),
value = as.numeric(sapply(E(outGraph)$UID, function(x){
unlist(inData %>%
filter(UID == x) %>%
.[[as.name(field.pass)]])
})))
# Convert pass field to numeric
outGraph <- set_edge_attr(outGraph,
name = as.name(field.pass),
index = E(outGraph),
value = ifelse(E(outGraph)$type == 'Junction',
1.0, E(outGraph)$Pass_R))
# Return output
return(outGraph)
}
# ---------------------------------------------------------------------------- #
# FUNCTION: calculate_dci() - Function calculates symmetric and aysmmetric DCI from a provided igraph object,
#                                    dataframe of barrier passability, and fields indicating the
#                                    passability, and weight fields of the input tables.
calculate_dci <- function(inGraph, scenario.id, field.pass, field.weight){
# Initialize output table
data.out <- data.frame(Scenario = character(0),
DCI_symm = numeric(0),
DCI_asym = numeric(0))
# Attribute pass_u and pass_d with joined passability values
field.pass <- c('pass_u', 'pass_d')
graph.out <- inGraph # NOTE: Must change graph here so that both pass_u and pass_d update
for(i in 1:length(field.pass)){
graph.out <- set_edge_attr(graph.out,
field.pass[i],
value = E(inGraph)$Pass_R)
}
# Calculate DCI.symmetric
dci.symm <- index_calculation(graph = graph.out,
weight = field.weight,
B_ij_flag = FALSE,
index_type = 'full',
dir_fragmentation_type = 'symmetric')
# Calculate DCI.asymmetric
dci.asym <- index_calculation(graph = graph.out,
weight = field.weight,
B_ij_flag = FALSE,
index_type = 'full',
dir_fragmentation_type = 'asymmetric')
# Attribute output
data.out <- data.out %>% add_row(Scenario = scenario.id,
DCI_symm = dci.symm$index,
DCI_asym = dci.asym$index)
# Return output
# return(graph.out)
return(data.out)
}
# ---------------------------------------------------------------------
# --------------------------------------------------------------------- #
# 03. Connectivity analysis (currently only Bear Lake)
# ---------------------------------------------------------------------
# NOTE: This step must be run prior to any connectivity analysis to initialize the graph object
# Summary: Load stream network, convert to igraph, and calculate no-barrier
#          DCI for validation.
# Declare data
file.data.results <- paste0(getwd(), '/Data_Results.xlsx')
# Load data
data.results <- rio::import_list(file = file.data.results)
# ---------------------------------------------------------------------------- #
# Generate and validate stream network iGraph for connectivity
# Declare stream network
data.network <- data.results[['Data_Network']]
# Add Field: UID (unique identifers for stream network nodes)
# Generate sequence of random numbers
set.seed(22)
# uid.seq <- str_pad(sample(999999, size = nrow(data.network)), width = 6, pad = '0')
data.network <- data.network %>%
mutate(UID = paste0('UID_', str_pad(sample(x = 999999, size = n()), width = 6, pad = '0'))) %>%
as.data.frame
# Add Field: Barrier_Expected (whether node is a dam/diversion/culvert or junction)
data.network <- data.network %>%
mutate(Barrier_Expected = ifelse(is.na(BarrierType), 'Junction', BarrierType)) %>%
as.data.frame
# Declare connectivity fields
graph.fields        <- c('From_Node', 'To_Node', 'Length_KM', 'UID', 'Barrier_Expected') # Fields to build graph with
attributes.edgeType <- 'Barrier_Expected' # String corresponding to barrier type.
attributes.edge     <- c('UID', 'Barrier_Expected') # Strings corresponding to edge (barrier) attributes.
attributes.node     <- c('From_Node', 'Length_KM') # String corresponding to node (stream segment) attributes. A field to weight connectivity indices is required, commonly assessed as length or HSI.
field.weight        <- 'Length_KM' # String corresponding to node attribute used to weight connectivity indices.
file.graph          <- 'iGraph_Network.png' # String indicating the name of the output file used to check igraph structure.
# Filter data for igraph
# NOTE: Input data represents the edge list
data.graph <- data.network %>% select({{graph.fields}})
# Check network structure
data.check <- network_check(inData = data.graph,
From_field = From_Node,
To_field = To_Node)
# Set outlet node as the 'From_Node' on the terminal reach
outlet <- data.check$Terminal_Reaches$From_Node
# Generate igraph object
graph.stream <- generate_attributed_igraph(inData          = data.graph,
From_field      = From_Node,
To_field        = To_Node,
EdgeType_field  = {{attributes.edgeType}},
Edge_attributes = {{attributes.edge}},
Node_attributes = {{attributes.node}},
Outlet_node     = outlet,
graphFile       = file.graph)
# Validate igraph object - All pass_u and pass_d are set to 1 (fully passable),
#                          so DCI should equal 1 (i.e. no fragementation)
index_calculation(graph = graph.stream,
weight = field.weight,
B_ij_flag = FALSE,
dir_fragmentation_type = 'symmetric')
# ---------------------------------------------------------------------------- #
# Explore iGraph object - Commands for viewing edge/vertex attributes
# View iGraph edge and vertex attribute fields
list.vertex.attributes(graph.stream)
list.edge.attributes(graph.stream)
# View iGraph edge and vertex attribute fields
get.vertex.attribute(graph.stream)
get.edge.attribute(graph.stream)
# View unique or specific values
unique(E(graph.stream)$type)
# ---------------------------------------------------------------------------- #
# Barrier passability scenarios for connectivity analysis
# Declare barrier data
data.barriers <- data.network %>%
filter(BarrierType != 'Junction') %>%
mutate(Mitigated = ifelse(Pass_Before == Pass_After, 'No', 'Yes'),
YearMitigated = ifelse(Pass_Before == Pass_After, NA, YearMitigated)) %>%
mutate(Pass_Before = ifelse(UID == 'UID_036254', Pass_After, Pass_Before)) %>%
select(UID, YearMitigated, Pass_Before, Pass_After) %>%
as.data.frame
# Passability scenarios
scenarios.barrier <- list()
scenarios.barrier[['SCN01_AllBarriers']] <- data.barriers %>% mutate(Pass_R = Pass_Before) %>% as.data.frame
# ---------------------------------------------------------------------------- #
# Calculate stream network connectivity
# Declare inputs
connectivity.field.pass   <- 'Pass_R'
connectivity.field.weight <- 'Length_KM'
# Initialize output
connectivity.out <- data.frame(Scenario = character(0),
DCI_symm = numeric(0),
DCI_asym = numeric(0))
# Calculate DCI connectivity for all barrier passability scenarios in list
for(i in 1:length(scenarios.barrier)){
# Declare scenario
scenario.id <- names(scenarios.barrier)[[i]]
# Join scenario barrier passability data to network
graph.barriers <- join_edge_attributes(inGraph = graph.stream,
inData = scenarios.barrier[[i]],
field.pass = 'Pass_R')
# Calculate DCI
data.connectivity <- calculate_dci(inGraph = graph.barriers,
scenario.id = scenario.id,
field.pass = 'Pass_R',
field.weight = 'Length_KM')
# Add data to output
connectivity.out <- rbind(connectivity.out, data.connectivity)
}
# ---------------------------------------------------------------------
connectivity.out
